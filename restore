#!/bin/bash

restoreFile="$HOME/.restore.info"
recycleBin="$HOME/recyclebin"

recursive=false

parseOpts() {
	while getopts ":r" opt; do
		case "$opt" in
		r)
			recursive=true
			;;
		\?)
			echo "$0: invalid option: -- $OPTARG"
			exit 8
			;;
		esac
	done
}

validateArgs() {
	if [ "$#" -le 0 ]; then
		echo "$0: no filename is provided"
		exit 1
	fi
}

validateFile() {
	if [ ! -e "$recycleBin/$1" ]; then
		echo "$0: file '$1' does not exist in '$recycleBin'"
		exit 2
	fi
}

escapeForRegex() {
	echo -n "$1" | sed -E 's/([][()^$+|.*\{}])/\\\1/g'
}

hasRecord() {
	record="$(getRecord "$1")"
	numberOfRecords="$(echo "$record" | wc -l)"

	if [ -z "$record" ]; then
		echo "$0: Can't find restore info for file '$1'"
		exit 3
	fi

	if [ "$numberOfRecords" -ge 2 ]; then
		echo "$0: Multiple restore info found for file '$1'"
		exit 5
	fi

	if [ "$(echo -n "$record" | cut -d':' -f1 2>/dev/null)" != "$1" ]; then
		echo "$0: Corrupt info for file '$1'"
		exit 3
	fi
}

# get record for a file with the recycled file name ({originalFileName}_{inodeNumber})
getRecord() {
	grep -Ee "^$(escapeForRegex "$1"):" "$restoreFile" 2>/dev/null
}

getRecordsFromAbsPath() {
	grep -Ee ":$(escapeForRegex "$1")" "$restoreFile"
}

# remove record for a file with the recycled file name ({originalFileName}_{inodeNumber})
removeRecord() {
	sed -i -E -e "/^$(escapeForRegex "$1"):/d" "$restoreFile"
}

# if there is no possible valid absolute path, then result is not well defined
recreateAbsPath() {
	local absPath

	if [ "${1:0:1}" == '/' ]; then
		absPath="$1"
	else
		absPath="$PWD/$1"
	fi

	# squeeze consecutive slashes
	absPath="$(echo -n "$PWD/$1" | sed -E 's:/{2,}:/:g')"

	# replace '/./' with '/'
	while echo -n "$absPath" | grep -qe '/\./'; do
		absPath="$(echo -n "$absPath" | sed 's:/\./:/:')"
	done

	# remove trailing '/.' or trailing '/'
	absPath="$(echo -n "$absPath" | sed -E 's:/\.$|/$::')"

	# resolve '..'
	while echo -n "$absPath" | grep -Eqe '/[^/]+/\.\.'; do
		absPath="$(echo -n "$absPath" | sed -E 's:/[^/]+/\.\.::')"
	done

	echo "$absPath"
}

askForOverwrite() {
	read -rp "Do you want to overwrite the existing file '$1'? (y/n): " answer
	if echo -n "$answer" | grep -qive '^y'; then
		exit 1
	fi
}

restoreFile() {
	validateFile "$1"

	if ! hasRecord "$1"; then
		exit $?
	fi

	absPath="$(getRecord "$1" | cut -d':' -f2)"
	if [ ! -e "$absPath" ] || askForOverwrite "$absPath"; then
		mkdir -p "$(dirname "$absPath")"
		mv "$recycleBin/$1" "$absPath"
		removeRecord "$1"
	fi
}

########
# main #
########

parseOpts "$@"
shift $((OPTIND - 1))
validateArgs "$@"

if $recursive; then
	IFS=$'\n'
	absPath="$(recreateAbsPath "$1")"
	for record in $(getRecordsFromAbsPath "$absPath"); do
		restoreFile "$(echo "$record" | cut -d':' -f1)"
	done
	unset IFS
else
	restoreFile "$1"
fi
