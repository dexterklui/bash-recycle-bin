#!/bin/bash

restoreFile="$HOME/.restore.info"
recycleBin="$HOME/recyclebin"

recursive=false

parseOpts() {
	while getopts ":r" opt; do
		case "$opt" in
		r)
			recursive=true
			;;
		\?)
			echo "$0: invalid option: -- $OPTARG"
			exit 8
			;;
		esac
	done
}

validateArgs() {
	if [ "$#" -le 0 ]; then
		echo "$0: no filename is provided"
		exit 1
	fi
}

validateFile() {
	if [ ! -e "$recycleBin/$1" ]; then
		echo "$0: file '$1' does not exist in '$recycleBin'"
		exit 2
	fi
}

escapeForRegex() {
	echo -n "$1" | sed -E 's/([][()^$+|.*\{}])/\\\1/g'
}

validateHasRecord() {
	record="$(getRecord "$1")"
	numberOfRecords="$(echo "$record" | wc -l)"

	if [ -z "$record" ]; then
		echo "$0: Can't find restore info for file '$1', may indicate a corrupted restore info file"
		exit 5
	fi

	if [ "$numberOfRecords" -ge 2 ]; then
		echo "$0: Multiple restore info found for file '$1', may indicate a corrupted restore info file"
		exit 5
	fi
}

# get record for a file with the recycled file name ({originalFileName}_{inodeNumber})
getRecord() {
	grep -Ee "^$(escapeForRegex "$1"):" "$restoreFile" 2>/dev/null
}

# find all records from .restore.info that is within the given absolute path,
# and then fill the result to the global variable 'records'
# arg1 - absolute path
# echo - error message if no records found
# exit - 3 if no records found
updateRecordsFromAbsPath() {
	records="$(grep -Ee ":$(escapeForRegex "$1")" "$restoreFile")"
	if [ -z "$records" ]; then
		echo "$0: Can't find any recycle record associated with path '$1'"
		exit 3
	fi
}

# remove record for a file with the recycled file name ({originalFileName}_{inodeNumber})
removeRecord() {
	sed -i -E -e "/^$(escapeForRegex "$1"):/d" "$restoreFile"
}

# if there is no possible valid absolute path, then result is not well defined
recreateAbsPath() {
	local absPath

	if [ "${1:0:1}" == '/' ]; then
		absPath="$1"
	else
		absPath="$PWD/$1"
	fi

	# squeeze consecutive slashes
	absPath="$(echo -n "$PWD/$1" | sed -E 's:/{2,}:/:g')"

	# replace '/./' with '/'
	while echo -n "$absPath" | grep -qe '/\./'; do
		absPath="$(echo -n "$absPath" | sed 's:/\./:/:')"
	done

	# remove trailing '/.' or trailing '/'
	absPath="$(echo -n "$absPath" | sed -E 's:/\.$|/$::')"

	# resolve '..'
	while echo -n "$absPath" | grep -Eqe '/[^/]+/\.\.'; do
		absPath="$(echo -n "$absPath" | sed -E 's:/[^/]+/\.\.::')"
	done

	echo "$absPath"
}

askForOverwrite() {
	read -rp "Do you want to overwrite the existing file '$1'? (y/n): " answer
	if echo -n "$answer" | grep -qive '^y'; then
		exit 1
	fi
}

restoreFile() {
	validateFile "$1"
	validateHasRecord "$1"

	absPath="$(getRecord "$1" | cut -d':' -f2)"
	if [ ! -e "$absPath" ] || askForOverwrite "$absPath"; then
		mkdir -p "$(dirname "$absPath")"
		mv "$recycleBin/$1" "$absPath"
		removeRecord "$1"
	fi
}

########
# main #
########

parseOpts "$@"
shift $((OPTIND - 1))
validateArgs "$@"

if $recursive; then
	IFS=$'\n'
	absPath="$(recreateAbsPath "$1")"
	updateRecordsFromAbsPath "$absPath"
	for record in $records; do
		restoreFile "$(echo "$record" | cut -d':' -f1)"
	done
	unset IFS
else
	restoreFile "$1"
fi
