#!/bin/bash

restoreFile="$HOME/.restore.info"
recycleBin="$HOME/recyclebin"

interactive=false
verbose=false
recursive=false

encounteredNonExistingFile=false
encounteredDir=false
attemptedToRecycleSelf=false

createRestoreFileIfNotExist() {
	if [ ! -e "$restoreFile" ]; then
		touch "$restoreFile"
	fi
}

parseOpts() {
	while getopts ":ivr" opt; do
		case "$opt" in
		i)
			interactive=true
			;;
		v)
			verbose=true
			;;
		r)
			recursive=true
			;;
		\?)
			echo "$0: invalid option: -- $OPTARG"
			exit 8
			;;
		esac
	done
}

validateArgs() {
	if [ "$#" -le 0 ]; then
		echo "$0: no filename is provided"
		exit 9
	fi
}

validateFile() {
	if [ ! -e "$1" ]; then
		echo "$0: file '$1' does not exist"
		encounteredNonExistingFile=true
		return 1
	fi

	if [ -d "$1" ] && ! $recursive; then
		echo "$0: '$1' is a directory, but expect a file"
		encounteredDir=true
		return 2
	fi

	if [ "$(realpath "$1")" == "$(readlink -f "$0")" ]; then
		echo "$0: cannot recycle itself"
		attemptedToRecycleSelf=true
		return 4
	fi
}

getRecycleFileName() {
	inodeNumber="$(ls -i "$1" | cut -d' ' -f1)"
	basefilename="$(basename "$1")"
	echo "${basefilename}_${inodeNumber}"
	unset inodeNumber
}

# 1st arg: recycle file name
# 2nd arg: absolute path
writeRecord() {
	record="$1:$2"

	# XXX: use regex, but only after escaping regex meta characters
	if grep -Fqe "$record" "$restoreFile"; then
		echo "$0: record '$record' already exists in '$restoreFile', you can't recycle same filename with same inode number"
		exit 10
	else
		echo "$record" >>"$restoreFile"
	fi
}

confirmRecycleIfInteractive() {
	if ! "$interactive"; then
		return 0
	fi
	read -p "Do you want to recycle '$1'? (y/n): " answer
	if echo -n "$answer" | grep -qive '^y'; then
		return 1
	fi
}

displayMessageIfVerbose() {
	if "$verbose"; then
		echo "Recycled '$1'"
	fi
}

# return 0 if successfully removed an empty directory
# otherwise return non-zero
rmDirInInteractiveMode() {
	if [ -d "$1" ]; then
		if [ -z "$(ls -A "$1")" ]; then
			# in recursive mode, remove an empty directory
			rmdir "$1"
			$verbose && echo "Removed empty directory '$1'"
			return 0
		else
			$verbose && echo "$0: in recursive mode trying to remove directory '$1', but it is not empty, so skipping"
			return 2
		fi
	fi
	return 1
}

recycleFile() {
	if ! validateFile "$1"; then
		return 1
	fi

	if ! confirmRecycleIfInteractive "$1"; then
		return 2
	fi

	if rmDirInInteractiveMode "$1"; then
		return 0
	fi

	absPath="$(realpath "$1")"
	recycleFileName="$(getRecycleFileName "$1")"

	mv "$1" "$recycleBin/$recycleFileName"
	displayMessageIfVerbose "$1"
	writeRecord "$recycleFileName:$absPath"
}

calculateExitCode() {
	local exitCode
	exitCode=0
	if $encounteredNonExistingFile; then
		(("exitCode+=1"))
	fi
	if $encounteredDir; then
		(("exitCode+=2"))
	fi
	if $attemptedToRecycleSelf; then
		(("exitCode+=4"))
	fi
	echo $exitCode
}

########
# main #
########

parseOpts "$@"
shift $((OPTIND - 1))
validateArgs "$@"
createRestoreFileIfNotExist
mkdir -p "$recycleBin"

for arg in "$@"; do
	if $recursive; then
		files=$(find "$arg" -depth)

		for f in $files; do
			recycleFile "$f"
		done
	else
		recycleFile "$arg"
	fi
done

exit "$(calculateExitCode)"
